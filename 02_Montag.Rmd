# Arbeiten mit Datensätzen in Stata {#Stata2} 

```{r setup2, echo = F, message=F, warning = F}
# .libPaths("D:/R-library")
knitr::opts_chunk$set(collapse = F)
library(Statamarkdown)
# # options(width = 200) # 157
# # "C:/Program Files/Stata16/StataSE-64.exe"
stataexe <- "C:/Program Files (x86)/Stata13/StataSE-64.exe"
knitr::opts_chunk$set(engine.path=list(stata=stataexe))
```

Nachdem wir uns in Stata etwas umgesehen haben, können wir uns jetzt 
```{stata tab_su1, eval = F}
cd ....
use "ZA5270_v2-0-0.dta"
```

## Vorab: Befehlsstruktur & Hilfe

Ganz nebenbei haben wir im Kapitel 1 bereits die ersten Stata-Befehle verwendet. Bevor wir jetzt aber tiefer einsteigen nochmal einmal ganz allgemein:

Die grundsätzliche Struktur von Stata-Kommandos ist immer `befehl variable, optionen`. Zunächst geben wir also immer an, was passieren soll - bisher war das eben zum Beispiel eine Beschreibung (`describe`) einer Variable: 
```{stata commands1, eval = F}
describe sex
```
```{stata commands2, echo = F}
set linesize 100
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
describe sex
```
Diese können wir mit der Option `short` abändern. Optionen werden nach einem `,` angegeben:

```{stata commands1s, eval = F}
describe sex, simple
```

```{stata commands2s, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
describe sex, simple
```

Befehle ohne Variable beziehen sich immer auf den gesamten Datensatz, bei `describe` bekommen wir damit dann eine Übersicht zum Datensatz:
```{stata commands3, eval = F}
describe, short
```

```{stata commands3show, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
describe, short
```

Mit `help` bekommen wir eine Hilfeseite angezeigt, hilfreich sind dabei vor allem die Beispiele ganz unten:
```{stata help_desc, eval = F}
help describe
```

```{r help_ansicht, echo = F,out.width = "40%",fig.height= 2.5, fig.align="center"}
knitr::include_graphics("02_help_describe.PNG")
```

Kommandos in Stata sind zeilenbasiert. D.h. alles was zu einem Kommando gehört, muss in der gleichen Zeile stehen. Umgekehrt wird auch alles, was in einer Zeile steht als Teil des Kommandos verstanden:
```{stata rowbased, eval = F}
describe pv01 age sex, short
```

```{stata rowbased1, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
describe pv01 age sex, short
```

Funktioniert nicht:
```{stata rowbased2, eval = F}
d pv01 age 
sex
```
```{stata rowbased2b, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
d pv01 age 
sex
```

Mit `///` können wir Zeilen verknüpfen:
```{stata rowbased3, eval = F}
d pv01 age ///
sex
```
```{stata rowbased3b, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
d pv01 age ///
sex
```

Außerdem können wir mit `//` Kommentare in unsere DoFiles einfügen. `//` blendet  alles folgende am Ende der Zeile aus:
```{stata comment, eval = F}
d pv01 age sex // dies ist ein kommentar
```
```{stata comment2, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
d pv01 age sex
```


## Auszählen & Überblick erhalten

Mit `summarize`  und `tabulate` bekommen wir eine Übersicht zu den Kennzahlen bzw. eine Auszählung der Häufigkeiten einer Variable. Dies sind wohl die beiden wichtigsten Befehle in Stata:

```{stata su1, eval = F}
summarize age
```

```{stata su1b, echo = F, collectcode=TRUE}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\ZA5270_v2-0-0.dta", clear
su age
```

```{stata su2, eval = F}
summarize age inc // klappt auch mit mehreren Variablen
```
```{stata su2b, echo = F, collectcode=TRUE}
summarize age inc // klappt auch mit mehreren Variablen
```


```{stata tab, eval = F}
tabulate sex
```

```{stata tabb, echo = F, collectcode=TRUE}
tab sex
```

## Neue Variablen erstellen

```{stata gen, echo = T, eval = F }
gen age_mon = age * 12
su age_mon
```

```{stata gen2, echo = F,collectcode=TRUE}
gen age_mon = age * 12
su age_mon
```

## gen ist gut, Kontrolle ist besser

```{stata bro_ansicht_cmd, eval = F}
bro respid age age_mon
```


```{r bro_ansicht, echo = F,out.width = "40%",fig.height= 2.5, fig.align="center"}
knitr::include_graphics("02_stata_browse_kontrolle.png")
```


## if Bedingungen

+ `>, <, ==, >=, <=`

```{stata browse_if, eval = F}
browse sex land if age <= 20
```

+ inrange, inlist

## Bestehende Variablen verändern
```{stata rep, eval = F, echo = T}
replace age = . if age < 0
```

## keep & drop

## Nochmal von vorne: Daten neu laden

Variable gelöscht, die doch nötig ist? Falsch recodiert? Das ist zwar ärgerlich, aber ein riesen Vorteil der DoFile-basierten Datenarbeit mit Stata ist die Reproduzierbarkeit. Wir können einfach nochmal von vorne anfangen. Dazu lesen wir die Original-Daten einfach erneut mit `use` ein. Allerdings ist dann eine Besonderheit zu beachten:

```{stata re_use, eval = F}
use "ZA5270_v2-0-0.dta"
```

`no; dataset in memory has changed since last saved`

Wir müssen erst den existierenden Datensatz mit `clear` löschen 
```{stata, eval = F, echo =T }
clear
use "ZA5270_v2-0-0.dta"
```
oder die `clear` Option für `use` verwenden:
```{stata, eval = F, echo =T }
use "ZA5270_v2-0-0.dta", clear
```

## Speichern

Natürlich können wir unsere Daten auch abspeichern, wenn alles wie gewünscht geklappt hat. Dafür gibt es den Befehl `save`, der analog zu `use` funktioniert. Wenn wir allerdings einfach wieder den Original-Datensatznamen angeben und in der Zwischenzeit Variablen erstellt oder gelöscht haben, dann bekommen wir folgende Fehlermeldung:

```{stata, eval = F}
cd ... 
save "ZA5270_v2-0-0.dta"
```
`file auto.dta already exists`   
`r(602);`

Wir geben also entweder einen anderen Dateinamen an:
```{stata, eval = F}
save "ZA5270_v2-0-0_neu.dta"
```
Oder wir teilen Stata mit der Option `replace` explizit mit, dass die Datei überschrieben werden soll:
```{stata, eval = F}
save "ZA5270_v2-0-0.dta", replace
```

## Übungen

+ Laden Sie den Datensatz `Allbus2018` in Stata. 

+ Erstellen Sie eine neue Variable mit dem Alter der Befragten im Jahr 2020!   

+ Wählen Sie alle Befragten aus, die nach 1960 geboren wurden und löschen Sie alle anderen aus dem Datensatz. 
+ Wie viele Spalten hat `nach_1960`? Wie viele Zeilen? Nutzen Sie für Ihre Antwort die Befehle die wir kennen gelernt haben.




## Fortgeschrittene Themen

### sortieren

### Indikatoren umdrehen

### Informationen aus mehreren Variablen


### Informationen aus mehreren Datensätzen



### egen {#egen}

`egen` ist die Erweiterung von `gen` und gibt uns die Möglichkeit, eine ganze Reihe von 

```{stata, cleanlog = F, eval = F}
bys agec: egen mean_inc = mean(inc)
bys agec: keep if _n == 1
list agec mean_inc
```
```{r, eval = F}
     +-------------------------+
     |         agec   mean_inc |
     |-------------------------|
  1. |  18-29 JAHRE   1026.236 |
  2. |  30-44 JAHRE   1729.861 |
  3. |  45-59 JAHRE   1915.664 |
  4. |  60-74 JAHRE   1567.953 |
  5. |  75-89 JAHRE   1454.949 |
     |-------------------------|
  6. | UEBER 89 JAH   1942.133 |
     +-------------------------+
```


### collapse

Manchmal möchten wir vielleicht nur einen Mittelwert pro Gruppe und die einzelnen Werte interessieren uns gar nicht. Wir möchten unseren Datensatz also verkürzen, sodass er lediglich einen Wert pro Gruppe enthält. Dazu
