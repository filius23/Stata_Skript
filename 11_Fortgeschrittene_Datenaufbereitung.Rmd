# Fortgeschrittene Themen {#adva}

```{r setup11, echo = F, message=F, warning = F}
.libPaths("D:/R-library4")
knitr::opts_chunk$set(collapse = F)
library(Statamarkdown)
# # options(width = 200) # 157
# # "C:/Program Files/Stata16/StataSE-64.exe"
stataexe <- "C:/Program Files (x86)/Stata13/StataSE-64.exe"
knitr::opts_chunk$set(engine.path=list(stata=stataexe))
```

## Wertelabels 
Wertelabels helfen, Informationen aus dem Codebuch direkt im Datensatz abzulegen und so das arbeiten zu erleichtern. Während Stata-Datensätze häufig mit Labels geliefert werden, müssen wir bei neu erstellten Variablen diese Labels selbst erstellen.

Bspw. wenn wir aus der Altersvariable des Allbus 2018 eine neue Altersgruppen-Variable erstellen:
```{stata age_cut11, eval = F}
egen age_cat = cut(age), at( 18 35 60 100 )
```
```{stata age_cut_tab11F, eval = F}
tabulate age_cat
```
```{stata age_cut_tab11, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\Allbus2018.dta", clear
qui egen age_cat = cut(age), at( 18 35 60 100 ) 
tabulate age_cat
```

Um `age_cat` besser zu beschriften definieren wir ein Wertelabel. Dazu verwenden wir `label define`, gefolgt von einem Objektnamen für dieses Label (hier `age_cat_lab`) und dann jeweils die Ausprägungen zusammen mit dem entsprechenden label in `""`. Dieses Label-Objekt wenden wir dann mit `label values` auf die Variable `age_cat` an:
```{stata lab11, eval = F}
label define age_cat_lab 18 "18-34 Jahre" 35 "35-29 Jahre" 60 "über 60 Jahre" 
label values age_cat age_cat_lab
tab age_cat
```

```{stata lab11b, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\Allbus2018.dta", clear
qui egen age_cat = cut(age), at( 18 35 60 100 ) 
label define age_cat_lab 18 "18-34 Jahre" 35 "35-29 Jahre" 60 "über 60 Jahre" 
label values age_cat age_cat_lab
tab age_cat
```

Wir können außerdem mit `label variable "Beschreibung"` die Variable selbst beschriften, um sie so leichter auffindbar zu machen 
```{stata lab111, eval = F}
describe age_cat
```

```{stata lab111b, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\Allbus2018.dta", clear
qui egen age_cat = cut(age), at( 18 35 60 100 ) 
d age_cat
```

```{stata lab112, eval = F}
label variable age_cat "3er Alterseinteilung"
```

```{stata lab112b, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\Allbus2018.dta", clear
qui egen age_cat = cut(age), at( 18 35 60 100 ) 
label variable age_cat "3er Alterseinteilung"
```
zB. wird dieses Label mit `lookfor` gefunden:
```{stata lab113, eval = F}
lookfor "Alters"
```
```{stata lab113b, echo = F}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\Allbus2018.dta", clear
qui egen age_cat = cut(age), at( 18 35 60 100 ) 
qui label define age_cat_lab 18 "18-34 Jahre" 35 "35-29 Jahre" 60 "über 60 Jahre" 
qui label values age_cat age_cat_lab
qui label variable age_cat "3er Alterseinteilung"
lookfor "Alters"
```

## sortieren
`sort`

## missings unterscheiden

## Indikatoren umdrehen

## Informationen aus mehreren Variablen

Manchmal liegt die gewünschte Information nur aufgeteilt auf mehrere Variablen vor. Ein Beispiel hierfür ist die Alterskonstellation von (Ehe-)Paaren. Im Allbus werden sowohl das Alter der Befragten (`age`) als auch (ggf.) das Alter der\*des Partner\*in abgefragt. Zudem unterscheidet der Allbus zwischen Lebens- (`page`) und Ehepartner\*innen (`scage`). Möchten wir jetzt die jeweils den Altersabstand zwischen dem Alter der männlichen und weiblichen (Ehe-)Partner berechnen[^0111], so müssen wir durch eine Kombination aus `gen` und `replace` in mehreren Schritten vorgehen. 


```{stata, eval = F}
set linesize 120
cd ""
use "Allbus_1980-2018.dta", clear
// missings ausschließen:
replace mstat = . if mstat < 0
mvdecode *yborn, mv( -41 -32 -10 -9 -7 -8 -6 -5 -4 -3 -1 )
mvdecode *age,   mv( -41 -32 -10 -9 -7 -8 -6 -5 -4 -3 -1 )
mvdecode *educ,   mv( -41 -32 -10 -9 -7 -8 -6 -5 -4 -3 -1 )

// Alter von ihr: entweder Befragtenalter wenn sie befragt wurde oder 
gen her_age =  age if sex == 2
// scage wenn *er* befragt wurde und verheiratet ist -> ihr Alter ist in scage
replace her_age = scage if sex == 1 & mstat == 1
// üage *er* befragt wurde und unverheiratet ist -> ihr Alter ist in page
replace her_age = page if sex == 1 & mstat != 1

// Alter von ihm: entweder Befragtenalter wenn er befragt wurde oder 
gen his_age =  age if sex == 1
// scage wenn *sie* befragt wurde und verheiratet ist -> ihr Alter ist in scage
replace his_age = scage if sex == 2 & mstat == 1
// page wenn *sie* befragt wurde und verheiratet ist -> ihre Alter ist in scage
replace his_age = page if sex == 2 & mstat != 1

gen age_diff = his_age - her_age if !missing(his_age) & !missing(her_age)
su age_diff
```

[^0111]: Diese Beispiel bezieht sich also nur auf heterosexuelle Paare.

## Informationen aus mehreren Datensätzen

`merge`

## Arbeiten mit Textvariablen

`substr`

`regexr`

`regexm`


## egen {#egen}

`egen` ist die Erweiterung von `gen` und gibt uns die Möglichkeit, eine ganze Reihe von Berechnungen durchzuführen.

## Subgruppen-Variablen erstellen mit `separate` {#sep1}

`separate` ist eine Abkürzung, um Angaben einer Variable entlang der Ausprägungen einer zweiten Variablen aufzuteilen. Das hilft uns bspw. die Aufteilung von `inc` nach dem Geschlecht (`sex`) zu vereinfachen. Wir können dies entweder mit zwei Befehlen mit `gen` und `if` durchführen oder diese zwei Schritte mit einem `separate` Befehl durchführen:

```{stata sepF, eval = F}
gen inc_m = inc if sex == 1
gen inc_f = inc if sex == 2
separate inc, by(sex)
list inc sex inc_m inc_f inc1 inc2 in 1/10
```


```{stata sepT, echo = F, cleanlog = T}
set linesize 80
qui use "D:\oCloud\Home-Cloud\Lehre\Methodenseminar\Allbus2018.dta", clear
gen inc_m = inc if sex == 1
gen inc_f = inc if sex == 2
separate inc, by(sex)
list inc sex inc_m inc_f inc1 inc2 in 1/10
```

## gruppierte Berechnungen

```{stata, cleanlog = F, eval = F}
bys agec: egen mean_inc = mean(inc)
list agec mean_inc in 1/10
```



## collapse

Manchmal möchten wir vielleicht nur einen Mittelwert pro Gruppe und die einzelnen Werte interessieren uns gar nicht. Wir möchten unseren Datensatz also verkürzen, sodass er lediglich einen Wert pro Gruppe enthält. Dazu
